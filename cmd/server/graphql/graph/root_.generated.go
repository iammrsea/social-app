// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/iammrsea/social-app/cmd/server/graphql/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	UserReputation() UserReputationResolver
	Vote() VoteResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Mutation struct {
		AwardBadge         func(childComplexity int, input model.AwardBadge) int
		BanUser            func(childComplexity int, id string) int
		ChangeUsername     func(childComplexity int, input model.ChangeUsername) int
		MakeModerator      func(childComplexity int, id string) int
		RegisterUser       func(childComplexity int, input model.RegisterUser) int
		RevokeAwardedBadge func(childComplexity int, input model.AwardBadge) int
		Vote               func(childComplexity int, input *model.VoteInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		GetUserByEmail func(childComplexity int, email string) int
		GetUserByID    func(childComplexity int, id string) int
		GetUsers       func(childComplexity int, first *int32, after *string) int
		GetVotes       func(childComplexity int) int
	}

	User struct {
		BanStatus  func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		Email      func(childComplexity int) int
		Id         func(childComplexity int) int
		Reputation func(childComplexity int) int
		Role       func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
		Username   func(childComplexity int) int
	}

	UserBanStatus struct {
		BanEndDate      func(childComplexity int) int
		BanStartDate    func(childComplexity int) int
		BannedAt        func(childComplexity int) int
		IsBanIndefinite func(childComplexity int) int
		IsBanned        func(childComplexity int) int
		ReasonForBan    func(childComplexity int) int
	}

	UserConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserReputation struct {
		Badges          func(childComplexity int) int
		ReputationScore func(childComplexity int) int
	}

	Vote struct {
		PostID func(childComplexity int) int
		Type   func(childComplexity int) int
		UserID func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Mutation.awardBadge":
		if e.complexity.Mutation.AwardBadge == nil {
			break
		}

		args, err := ec.field_Mutation_awardBadge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AwardBadge(childComplexity, args["input"].(model.AwardBadge)), true

	case "Mutation.banUser":
		if e.complexity.Mutation.BanUser == nil {
			break
		}

		args, err := ec.field_Mutation_banUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BanUser(childComplexity, args["id"].(string)), true

	case "Mutation.changeUsername":
		if e.complexity.Mutation.ChangeUsername == nil {
			break
		}

		args, err := ec.field_Mutation_changeUsername_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChangeUsername(childComplexity, args["input"].(model.ChangeUsername)), true

	case "Mutation.makeModerator":
		if e.complexity.Mutation.MakeModerator == nil {
			break
		}

		args, err := ec.field_Mutation_makeModerator_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MakeModerator(childComplexity, args["id"].(string)), true

	case "Mutation.registerUser":
		if e.complexity.Mutation.RegisterUser == nil {
			break
		}

		args, err := ec.field_Mutation_registerUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterUser(childComplexity, args["input"].(model.RegisterUser)), true

	case "Mutation.revokeAwardedBadge":
		if e.complexity.Mutation.RevokeAwardedBadge == nil {
			break
		}

		args, err := ec.field_Mutation_revokeAwardedBadge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeAwardedBadge(childComplexity, args["input"].(model.AwardBadge)), true

	case "Mutation.vote":
		if e.complexity.Mutation.Vote == nil {
			break
		}

		args, err := ec.field_Mutation_vote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Vote(childComplexity, args["input"].(*model.VoteInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.getUserByEmail":
		if e.complexity.Query.GetUserByEmail == nil {
			break
		}

		args, err := ec.field_Query_getUserByEmail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUserByEmail(childComplexity, args["email"].(string)), true

	case "Query.getUserById":
		if e.complexity.Query.GetUserByID == nil {
			break
		}

		args, err := ec.field_Query_getUserById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUserByID(childComplexity, args["id"].(string)), true

	case "Query.getUsers":
		if e.complexity.Query.GetUsers == nil {
			break
		}

		args, err := ec.field_Query_getUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUsers(childComplexity, args["first"].(*int32), args["after"].(*string)), true

	case "Query.getVotes":
		if e.complexity.Query.GetVotes == nil {
			break
		}

		return e.complexity.Query.GetVotes(childComplexity), true

	case "User.banStatus":
		if e.complexity.User.BanStatus == nil {
			break
		}

		return e.complexity.User.BanStatus(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.Id == nil {
			break
		}

		return e.complexity.User.Id(childComplexity), true

	case "User.reputation":
		if e.complexity.User.Reputation == nil {
			break
		}

		return e.complexity.User.Reputation(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "UserBanStatus.banEndDate":
		if e.complexity.UserBanStatus.BanEndDate == nil {
			break
		}

		return e.complexity.UserBanStatus.BanEndDate(childComplexity), true

	case "UserBanStatus.banStartDate":
		if e.complexity.UserBanStatus.BanStartDate == nil {
			break
		}

		return e.complexity.UserBanStatus.BanStartDate(childComplexity), true

	case "UserBanStatus.bannedAt":
		if e.complexity.UserBanStatus.BannedAt == nil {
			break
		}

		return e.complexity.UserBanStatus.BannedAt(childComplexity), true

	case "UserBanStatus.isBanIndefinite":
		if e.complexity.UserBanStatus.IsBanIndefinite == nil {
			break
		}

		return e.complexity.UserBanStatus.IsBanIndefinite(childComplexity), true

	case "UserBanStatus.isBanned":
		if e.complexity.UserBanStatus.IsBanned == nil {
			break
		}

		return e.complexity.UserBanStatus.IsBanned(childComplexity), true

	case "UserBanStatus.reasonForBan":
		if e.complexity.UserBanStatus.ReasonForBan == nil {
			break
		}

		return e.complexity.UserBanStatus.ReasonForBan(childComplexity), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	case "UserReputation.badges":
		if e.complexity.UserReputation.Badges == nil {
			break
		}

		return e.complexity.UserReputation.Badges(childComplexity), true

	case "UserReputation.reputationScore":
		if e.complexity.UserReputation.ReputationScore == nil {
			break
		}

		return e.complexity.UserReputation.ReputationScore(childComplexity), true

	case "Vote.postId":
		if e.complexity.Vote.PostID == nil {
			break
		}

		return e.complexity.Vote.PostID(childComplexity), true

	case "Vote.type":
		if e.complexity.Vote.Type == nil {
			break
		}

		return e.complexity.Vote.Type(childComplexity), true

	case "Vote.userId":
		if e.complexity.Vote.UserID == nil {
			break
		}

		return e.complexity.Vote.UserID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAwardBadge,
		ec.unmarshalInputChangeUsername,
		ec.unmarshalInputRegisterUser,
		ec.unmarshalInputVoteInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../base_schema.graphql", Input: `type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
}
`, BuiltIn: false},
	{Name: "../../../../internal/interaction/ports/graph/vote_schema.graphql", Input: `type Vote {
    userId: String!
    postId: String!
    type: String!
}

extend type Query {
    getVotes: [Vote]!
}

input VoteInput {
    userId: String!
    postId: String!
    type: String!
}

extend type Mutation {
    vote(input: VoteInput): Vote
}
`, BuiltIn: false},
	{Name: "../../../../internal/user/ports/graph/user_schema.graphql", Input: `scalar Time

type User {
    id: String!
    username: String!
    email: String!
    role: UserRole!
    reputation: UserReputation
    createdAt: Time!
    updatedAt: Time!
    banStatus: UserBanStatus!
}

type UserEdge {
    node: User!
    cursor: String!
}

type UserConnection {
    edges: [UserEdge!]!
    pageInfo: PageInfo!
}

type UserReputation {
    reputationScore: Int!
    badges: [String!]!
}

type UserBanStatus {
    bannedAt: Time
    banStartDate: Time
    banEndDate: Time
    isBanIndefinite: Boolean
    reasonForBan: String
    isBanned: Boolean!
}

enum UserRole {
    REGULAR
    MODERATOR
    ADMIN
}

input ChangeUsername {
    id: String!
    username: String!
}

input RegisterUser {
    email: String!
    username: String!
}

extend type Query {
    getUserById(id: String!): User
    getUsers(first: Int = 10, after: String): UserConnection!
    getUserByEmail(email: String!): User
}

input AwardBadge {
    id: String!
    badge: String!
}

extend type Mutation {
    changeUsername(input: ChangeUsername!): User
    makeModerator(id: String!): User
    banUser(id: String!): User
    registerUser(input: RegisterUser!): User
    awardBadge(input: AwardBadge!): User
    revokeAwardedBadge(input: AwardBadge!): User
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
